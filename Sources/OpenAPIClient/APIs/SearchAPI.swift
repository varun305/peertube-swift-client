//
// SearchAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

open class SearchAPI {

    /**
     * enum for parameter searchTarget
     */
    public enum SearchTarget_searchChannels: String, Sendable, CaseIterable {
        case local = "local"
        case searchIndex = "search-index"
    }

    /**
     Search channels
     
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete channel information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter handles: (query) Find elements with these handles (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoChannelList
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func searchChannels(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchChannels? = nil, sort: String? = nil, host: String? = nil, handles: [String]? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoChannelList {
        return try await searchChannelsWithRequestBuilder(search: search, start: start, count: count, searchTarget: searchTarget, sort: sort, host: host, handles: handles, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Search channels
     - GET /api/v1/search/video-channels
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete channel information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter handles: (query) Find elements with these handles (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoChannelList> 
     */
    open class func searchChannelsWithRequestBuilder(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchChannels? = nil, sort: String? = nil, host: String? = nil, handles: [String]? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoChannelList> {
        let localVariablePath = "/api/v1/search/video-channels"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "search": (wrappedValue: search.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchTarget": (wrappedValue: searchTarget?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "host": (wrappedValue: host?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "handles": (wrappedValue: handles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoChannelList>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter searchTarget
     */
    public enum SearchTarget_searchPlaylists: String, Sendable, CaseIterable {
        case local = "local"
        case searchIndex = "search-index"
    }

    /**
     Search playlists
     
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete playlist information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter uuids: (query) Find elements with specific UUIDs (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: ApiV1VideoChannelsChannelHandleVideoPlaylistsGet200Response
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func searchPlaylists(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchPlaylists? = nil, sort: String? = nil, host: String? = nil, uuids: [String]? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> ApiV1VideoChannelsChannelHandleVideoPlaylistsGet200Response {
        return try await searchPlaylistsWithRequestBuilder(search: search, start: start, count: count, searchTarget: searchTarget, sort: sort, host: host, uuids: uuids, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Search playlists
     - GET /api/v1/search/video-playlists
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete playlist information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter uuids: (query) Find elements with specific UUIDs (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ApiV1VideoChannelsChannelHandleVideoPlaylistsGet200Response> 
     */
    open class func searchPlaylistsWithRequestBuilder(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchPlaylists? = nil, sort: String? = nil, host: String? = nil, uuids: [String]? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<ApiV1VideoChannelsChannelHandleVideoPlaylistsGet200Response> {
        let localVariablePath = "/api/v1/search/video-playlists"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "search": (wrappedValue: search.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchTarget": (wrappedValue: searchTarget?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "host": (wrappedValue: host?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "uuids": (wrappedValue: uuids?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ApiV1VideoChannelsChannelHandleVideoPlaylistsGet200Response>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_searchVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter include
     */
    public enum Include_searchVideos: Int, Sendable, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case _4 = 4
        case _8 = 8
        case _16 = 16
        case _32 = 32
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_searchVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter searchTarget
     */
    public enum SearchTarget_searchVideos: String, Sendable, CaseIterable {
        case local = "local"
        case searchIndex = "search-index"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_searchVideos: String, Sendable, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case match = "-match"
    }

    /**
     Search videos
     
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.  
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter uuids: (query) Find elements with specific UUIDs (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort videos by criteria (prefixing with &#x60;-&#x60; means &#x60;DESC&#x60; order):  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter startDate: (query) Get videos that are published after this date (optional)
     - parameter endDate: (query) Get videos that are published before this date (optional)
     - parameter originallyPublishedStartDate: (query) Get videos that are originally published after this date (optional)
     - parameter originallyPublishedEndDate: (query) Get videos that are originally published before this date (optional)
     - parameter durationMin: (query) Get videos that have this minimum duration (optional)
     - parameter durationMax: (query) Get videos that have this maximum duration (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoListResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func searchVideos(search: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_searchVideos? = nil, isLocal: Bool? = nil, include: Include_searchVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, uuids: [String]? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_searchVideos? = nil, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideos? = nil, sort: Sort_searchVideos? = nil, excludeAlreadyWatched: Bool? = nil, host: String? = nil, startDate: Date? = nil, endDate: Date? = nil, originallyPublishedStartDate: Date? = nil, originallyPublishedEndDate: Date? = nil, durationMin: Int? = nil, durationMax: Int? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoListResponse {
        return try await searchVideosWithRequestBuilder(search: search, categoryOneOf: categoryOneOf, isLive: isLive, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, autoTagOneOf: autoTagOneOf, nsfw: nsfw, isLocal: isLocal, include: include, privacyOneOf: privacyOneOf, uuids: uuids, hasHLSFiles: hasHLSFiles, hasWebVideoFiles: hasWebVideoFiles, skipCount: skipCount, start: start, count: count, searchTarget: searchTarget, sort: sort, excludeAlreadyWatched: excludeAlreadyWatched, host: host, startDate: startDate, endDate: endDate, originallyPublishedStartDate: originallyPublishedStartDate, originallyPublishedEndDate: originallyPublishedEndDate, durationMin: durationMin, durationMax: durationMax, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Search videos
     - GET /api/v1/search/videos
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.  
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter uuids: (query) Find elements with specific UUIDs (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort videos by criteria (prefixing with &#x60;-&#x60; means &#x60;DESC&#x60; order):  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter startDate: (query) Get videos that are published after this date (optional)
     - parameter endDate: (query) Get videos that are published before this date (optional)
     - parameter originallyPublishedStartDate: (query) Get videos that are originally published after this date (optional)
     - parameter originallyPublishedEndDate: (query) Get videos that are originally published before this date (optional)
     - parameter durationMin: (query) Get videos that have this minimum duration (optional)
     - parameter durationMax: (query) Get videos that have this maximum duration (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func searchVideosWithRequestBuilder(search: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_searchVideos? = nil, isLocal: Bool? = nil, include: Include_searchVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, uuids: [String]? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_searchVideos? = nil, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideos? = nil, sort: Sort_searchVideos? = nil, excludeAlreadyWatched: Bool? = nil, host: String? = nil, startDate: Date? = nil, endDate: Date? = nil, originallyPublishedStartDate: Date? = nil, originallyPublishedEndDate: Date? = nil, durationMin: Int? = nil, durationMax: Int? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoListResponse> {
        let localVariablePath = "/api/v1/search/videos"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "search": (wrappedValue: search.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "categoryOneOf": (wrappedValue: categoryOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLive": (wrappedValue: isLive?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsOneOf": (wrappedValue: tagsOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsAllOf": (wrappedValue: tagsAllOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "licenceOneOf": (wrappedValue: licenceOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "languageOneOf": (wrappedValue: languageOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "autoTagOneOf": (wrappedValue: autoTagOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "nsfw": (wrappedValue: nsfw?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLocal": (wrappedValue: isLocal?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "include": (wrappedValue: include?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "privacyOneOf": (wrappedValue: privacyOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "uuids": (wrappedValue: uuids?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasHLSFiles": (wrappedValue: hasHLSFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasWebVideoFiles": (wrappedValue: hasWebVideoFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "skipCount": (wrappedValue: skipCount?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchTarget": (wrappedValue: searchTarget?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "excludeAlreadyWatched": (wrappedValue: excludeAlreadyWatched?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "host": (wrappedValue: host?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "startDate": (wrappedValue: startDate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endDate": (wrappedValue: endDate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "originallyPublishedStartDate": (wrappedValue: originallyPublishedStartDate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "originallyPublishedEndDate": (wrappedValue: originallyPublishedEndDate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "durationMin": (wrappedValue: durationMin?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "durationMax": (wrappedValue: durationMax?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoListResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }
}
