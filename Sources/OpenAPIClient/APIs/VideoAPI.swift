//
// VideoAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

open class VideoAPI {

    /**
     Create a live
     
     - parameter channelId: (form) Channel id that will contain this live video 
     - parameter name: (form) Live video/replay name 
     - parameter saveReplay: (form)  (optional)
     - parameter replaySettings: (form)  (optional)
     - parameter permanentLive: (form) User can stream multiple times in a permanent live (optional)
     - parameter latencyMode: (form)  (optional)
     - parameter thumbnailfile: (form) Live video/replay thumbnail file (optional)
     - parameter previewfile: (form) Live video/replay preview file (optional)
     - parameter privacy: (form)  (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter description: (form) Live video/replay description (optional)
     - parameter support: (form) A text tell the audience how to support the creator (optional)
     - parameter nsfw: (form) Whether or not this live video/replay contains sensitive content (optional)
     - parameter tags: (form) Live video/replay tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Deprecated in 6.2, use commentsPolicy instead (optional)
     - parameter commentsPolicy: (form)  (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for the replay of this live video (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoUploadResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func addLive(channelId: Int, name: String, saveReplay: Bool? = nil, replaySettings: LiveVideoReplaySettings? = nil, permanentLive: Bool? = nil, latencyMode: LiveVideoLatencyMode? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, support: String? = nil, nsfw: Bool? = nil, tags: [String]? = nil, commentsEnabled: Bool? = nil, commentsPolicy: VideoCommentsPolicySet? = nil, downloadEnabled: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoUploadResponse {
        return try await addLiveWithRequestBuilder(channelId: channelId, name: name, saveReplay: saveReplay, replaySettings: replaySettings, permanentLive: permanentLive, latencyMode: latencyMode, thumbnailfile: thumbnailfile, previewfile: previewfile, privacy: privacy, category: category, licence: licence, language: language, description: description, support: support, nsfw: nsfw, tags: tags, commentsEnabled: commentsEnabled, commentsPolicy: commentsPolicy, downloadEnabled: downloadEnabled, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Create a live
     - POST /api/v1/videos/live
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter channelId: (form) Channel id that will contain this live video 
     - parameter name: (form) Live video/replay name 
     - parameter saveReplay: (form)  (optional)
     - parameter replaySettings: (form)  (optional)
     - parameter permanentLive: (form) User can stream multiple times in a permanent live (optional)
     - parameter latencyMode: (form)  (optional)
     - parameter thumbnailfile: (form) Live video/replay thumbnail file (optional)
     - parameter previewfile: (form) Live video/replay preview file (optional)
     - parameter privacy: (form)  (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter description: (form) Live video/replay description (optional)
     - parameter support: (form) A text tell the audience how to support the creator (optional)
     - parameter nsfw: (form) Whether or not this live video/replay contains sensitive content (optional)
     - parameter tags: (form) Live video/replay tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Deprecated in 6.2, use commentsPolicy instead (optional)
     - parameter commentsPolicy: (form)  (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for the replay of this live video (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoUploadResponse> 
     */
    open class func addLiveWithRequestBuilder(channelId: Int, name: String, saveReplay: Bool? = nil, replaySettings: LiveVideoReplaySettings? = nil, permanentLive: Bool? = nil, latencyMode: LiveVideoLatencyMode? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, support: String? = nil, nsfw: Bool? = nil, tags: [String]? = nil, commentsEnabled: Bool? = nil, commentsPolicy: VideoCommentsPolicySet? = nil, downloadEnabled: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoUploadResponse> {
        let localVariablePath = "/api/v1/videos/live"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "channelId": channelId.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "saveReplay": saveReplay?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "replaySettings": replaySettings?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "permanentLive": permanentLive?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "latencyMode": latencyMode?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "thumbnailfile": thumbnailfile?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "previewfile": previewfile?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "privacy": privacy?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "category": category?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "licence": licence?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "language": language?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "description": description?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "support": support?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "nsfw": nsfw?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "name": name.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "tags": tags?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "commentsEnabled": commentsEnabled?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "commentsPolicy": commentsPolicy?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "downloadEnabled": downloadEnabled?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoUploadResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Notify user is watching a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter userViewingVideo: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func addView(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, userViewingVideo: UserViewingVideo, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await addViewWithRequestBuilder(id: id, userViewingVideo: userViewingVideo, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Notify user is watching a video
     - POST /api/v1/videos/{id}/views
     - Call this endpoint regularly (every 5-10 seconds for example) to notify the server the user is watching the video. After a while, PeerTube will increase video's viewers counter. If the user is authenticated, PeerTube will also store the current player time.
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter userViewingVideo: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func addViewWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, userViewingVideo: UserViewingVideo, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}/views"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: userViewingVideo, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Create a studio task
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func apiV1VideosIdStudioEditPost(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await apiV1VideosIdStudioEditPostWithRequestBuilder(id: id, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Create a studio task
     - POST /api/v1/videos/{id}/studio/edit
     - Create a task to edit a video  (cut, add intro/outro etc)
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func apiV1VideosIdStudioEditPostWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}/studio/edit"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Set watching progress of a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter userViewingVideo: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func apiV1VideosIdWatchingPut(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, userViewingVideo: UserViewingVideo, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await apiV1VideosIdWatchingPutWithRequestBuilder(id: id, userViewingVideo: userViewingVideo, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Set watching progress of a video
     - PUT /api/v1/videos/{id}/watching
     - This endpoint has been deprecated. Use `/videos/{id}/views` instead
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter userViewingVideo: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func apiV1VideosIdWatchingPutWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, userViewingVideo: UserViewingVideo, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}/watching"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: userViewingVideo, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func delVideo(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await delVideoWithRequestBuilder(id: id, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Delete a video
     - DELETE /api/v1/videos/{id}
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func delVideoWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete video source file
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func deleteVideoSourceFile(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await deleteVideoSourceFileWithRequestBuilder(id: id, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Delete video source file
     - DELETE /api/v1/videos/{id}/source/file
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteVideoSourceFileWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}/source/file"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_getAccountVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter include
     */
    public enum Include_getAccountVideos: Int, Sendable, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case _4 = 4
        case _8 = 8
        case _16 = 16
        case _32 = 32
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_getAccountVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAccountVideos: String, Sendable, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case trending = "-trending"
        case hot = "-hot"
        case best = "-best"
    }

    /**
     List videos of an account
     
     - parameter name: (path) The username or handle of the account 
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter search: (query) Plain text search, applied to various parts of the model depending on endpoint (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoListResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getAccountVideos(name: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_getAccountVideos? = nil, host: String? = nil, isLocal: Bool? = nil, include: Include_getAccountVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getAccountVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getAccountVideos? = nil, excludeAlreadyWatched: Bool? = nil, search: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoListResponse {
        return try await getAccountVideosWithRequestBuilder(name: name, categoryOneOf: categoryOneOf, isLive: isLive, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, autoTagOneOf: autoTagOneOf, nsfw: nsfw, host: host, isLocal: isLocal, include: include, privacyOneOf: privacyOneOf, hasHLSFiles: hasHLSFiles, hasWebVideoFiles: hasWebVideoFiles, skipCount: skipCount, start: start, count: count, sort: sort, excludeAlreadyWatched: excludeAlreadyWatched, search: search, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     List videos of an account
     - GET /api/v1/accounts/{name}/videos
     - parameter name: (path) The username or handle of the account 
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter search: (query) Plain text search, applied to various parts of the model depending on endpoint (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func getAccountVideosWithRequestBuilder(name: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_getAccountVideos? = nil, host: String? = nil, isLocal: Bool? = nil, include: Include_getAccountVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getAccountVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getAccountVideos? = nil, excludeAlreadyWatched: Bool? = nil, search: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoListResponse> {
        var localVariablePath = "/api/v1/accounts/{name}/videos"
        let namePreEscape = "\(APIHelper.mapValueToPathItem(name))"
        let namePostEscape = namePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{name}", with: namePostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "categoryOneOf": (wrappedValue: categoryOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLive": (wrappedValue: isLive?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsOneOf": (wrappedValue: tagsOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsAllOf": (wrappedValue: tagsAllOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "licenceOneOf": (wrappedValue: licenceOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "languageOneOf": (wrappedValue: languageOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "autoTagOneOf": (wrappedValue: autoTagOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "nsfw": (wrappedValue: nsfw?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "host": (wrappedValue: host?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLocal": (wrappedValue: isLocal?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "include": (wrappedValue: include?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "privacyOneOf": (wrappedValue: privacyOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasHLSFiles": (wrappedValue: hasHLSFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasWebVideoFiles": (wrappedValue: hasWebVideoFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "skipCount": (wrappedValue: skipCount?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "excludeAlreadyWatched": (wrappedValue: excludeAlreadyWatched?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "search": (wrappedValue: search?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoListResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     List available video categories
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: [String]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getCategories(apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> [String] {
        return try await getCategoriesWithRequestBuilder(apiConfiguration: apiConfiguration).execute().body
    }

    /**
     List available video categories
     - GET /api/v1/videos/categories
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<[String]> 
     */
    open class func getCategoriesWithRequestBuilder(apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<[String]> {
        let localVariablePath = "/api/v1/videos/categories"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     List available video languages
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: [String]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getLanguages(apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> [String] {
        return try await getLanguagesWithRequestBuilder(apiConfiguration: apiConfiguration).execute().body
    }

    /**
     List available video languages
     - GET /api/v1/videos/languages
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<[String]> 
     */
    open class func getLanguagesWithRequestBuilder(apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<[String]> {
        let localVariablePath = "/api/v1/videos/languages"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     List available video licences
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: [String]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getLicences(apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> [String] {
        return try await getLicencesWithRequestBuilder(apiConfiguration: apiConfiguration).execute().body
    }

    /**
     List available video licences
     - GET /api/v1/videos/licences
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<[String]> 
     */
    open class func getLicencesWithRequestBuilder(apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<[String]> {
        let localVariablePath = "/api/v1/videos/licences"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Get information about a live
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: LiveVideoResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getLiveId(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> LiveVideoResponse {
        return try await getLiveIdWithRequestBuilder(id: id, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Get information about a live
     - GET /api/v1/videos/live/{id}
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<LiveVideoResponse> 
     */
    open class func getLiveIdWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<LiveVideoResponse> {
        var localVariablePath = "/api/v1/videos/live/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<LiveVideoResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoDetails
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getVideo(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoDetails {
        return try await getVideoWithRequestBuilder(id: id, xPeertubeVideoPassword: xPeertubeVideoPassword, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Get a video
     - GET /api/v1/videos/{id}
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoDetails> 
     */
    open class func getVideoWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoDetails> {
        var localVariablePath = "/api/v1/videos/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "x-peertube-video-password": xPeertubeVideoPassword?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoDetails>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_getVideoChannelVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter include
     */
    public enum Include_getVideoChannelVideos: Int, Sendable, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case _4 = 4
        case _8 = 8
        case _16 = 16
        case _32 = 32
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_getVideoChannelVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getVideoChannelVideos: String, Sendable, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case trending = "-trending"
        case hot = "-hot"
        case best = "-best"
    }

    /**
     List videos of a video channel
     
     - parameter channelHandle: (path) The video channel handle 
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter search: (query) Plain text search, applied to various parts of the model depending on endpoint (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoListResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getVideoChannelVideos(channelHandle: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, host: String? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_getVideoChannelVideos? = nil, isLocal: Bool? = nil, include: Include_getVideoChannelVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getVideoChannelVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getVideoChannelVideos? = nil, excludeAlreadyWatched: Bool? = nil, search: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoListResponse {
        return try await getVideoChannelVideosWithRequestBuilder(channelHandle: channelHandle, categoryOneOf: categoryOneOf, isLive: isLive, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, host: host, autoTagOneOf: autoTagOneOf, nsfw: nsfw, isLocal: isLocal, include: include, privacyOneOf: privacyOneOf, hasHLSFiles: hasHLSFiles, hasWebVideoFiles: hasWebVideoFiles, skipCount: skipCount, start: start, count: count, sort: sort, excludeAlreadyWatched: excludeAlreadyWatched, search: search, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     List videos of a video channel
     - GET /api/v1/video-channels/{channelHandle}/videos
     - parameter channelHandle: (path) The video channel handle 
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter search: (query) Plain text search, applied to various parts of the model depending on endpoint (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func getVideoChannelVideosWithRequestBuilder(channelHandle: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, host: String? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_getVideoChannelVideos? = nil, isLocal: Bool? = nil, include: Include_getVideoChannelVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getVideoChannelVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getVideoChannelVideos? = nil, excludeAlreadyWatched: Bool? = nil, search: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoListResponse> {
        var localVariablePath = "/api/v1/video-channels/{channelHandle}/videos"
        let channelHandlePreEscape = "\(APIHelper.mapValueToPathItem(channelHandle))"
        let channelHandlePostEscape = channelHandlePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{channelHandle}", with: channelHandlePostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "categoryOneOf": (wrappedValue: categoryOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLive": (wrappedValue: isLive?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsOneOf": (wrappedValue: tagsOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsAllOf": (wrappedValue: tagsAllOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "licenceOneOf": (wrappedValue: licenceOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "languageOneOf": (wrappedValue: languageOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "host": (wrappedValue: host?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "autoTagOneOf": (wrappedValue: autoTagOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "nsfw": (wrappedValue: nsfw?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLocal": (wrappedValue: isLocal?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "include": (wrappedValue: include?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "privacyOneOf": (wrappedValue: privacyOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasHLSFiles": (wrappedValue: hasHLSFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasWebVideoFiles": (wrappedValue: hasWebVideoFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "skipCount": (wrappedValue: skipCount?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "excludeAlreadyWatched": (wrappedValue: excludeAlreadyWatched?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "search": (wrappedValue: search?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoListResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Get complete video description
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: String
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getVideoDesc(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> String {
        return try await getVideoDescWithRequestBuilder(id: id, xPeertubeVideoPassword: xPeertubeVideoPassword, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Get complete video description
     - GET /api/v1/videos/{id}/description
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<String> 
     */
    open class func getVideoDescWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<String> {
        var localVariablePath = "/api/v1/videos/{id}/description"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "x-peertube-video-password": xPeertubeVideoPassword?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<String>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     List available video privacy policies
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: [String]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getVideoPrivacyPolicies(apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> [String] {
        return try await getVideoPrivacyPoliciesWithRequestBuilder(apiConfiguration: apiConfiguration).execute().body
    }

    /**
     List available video privacy policies
     - GET /api/v1/videos/privacies
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<[String]> 
     */
    open class func getVideoPrivacyPoliciesWithRequestBuilder(apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<[String]> {
        let localVariablePath = "/api/v1/videos/privacies"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Get video source file metadata
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoSource
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getVideoSource(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoSource {
        return try await getVideoSourceWithRequestBuilder(id: id, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Get video source file metadata
     - GET /api/v1/videos/{id}/source
     - Get metadata and download link of original video file
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoSource> 
     */
    open class func getVideoSourceWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoSource> {
        var localVariablePath = "/api/v1/videos/{id}/source"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoSource>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_getVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter include
     */
    public enum Include_getVideos: Int, Sendable, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case _4 = 4
        case _8 = 8
        case _16 = 16
        case _32 = 32
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_getVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getVideos: String, Sendable, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case trending = "-trending"
        case hot = "-hot"
        case best = "-best"
    }

    /**
     List videos
     
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter search: (query) Plain text search, applied to various parts of the model depending on endpoint (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoListResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getVideos(categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, host: String? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_getVideos? = nil, isLocal: Bool? = nil, include: Include_getVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getVideos? = nil, excludeAlreadyWatched: Bool? = nil, search: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoListResponse {
        return try await getVideosWithRequestBuilder(categoryOneOf: categoryOneOf, isLive: isLive, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, host: host, autoTagOneOf: autoTagOneOf, nsfw: nsfw, isLocal: isLocal, include: include, privacyOneOf: privacyOneOf, hasHLSFiles: hasHLSFiles, hasWebVideoFiles: hasWebVideoFiles, skipCount: skipCount, start: start, count: count, sort: sort, excludeAlreadyWatched: excludeAlreadyWatched, search: search, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     List videos
     - GET /api/v1/videos
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter search: (query) Plain text search, applied to various parts of the model depending on endpoint (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func getVideosWithRequestBuilder(categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, host: String? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_getVideos? = nil, isLocal: Bool? = nil, include: Include_getVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getVideos? = nil, excludeAlreadyWatched: Bool? = nil, search: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoListResponse> {
        let localVariablePath = "/api/v1/videos"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "categoryOneOf": (wrappedValue: categoryOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLive": (wrappedValue: isLive?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsOneOf": (wrappedValue: tagsOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsAllOf": (wrappedValue: tagsAllOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "licenceOneOf": (wrappedValue: licenceOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "languageOneOf": (wrappedValue: languageOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "host": (wrappedValue: host?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "autoTagOneOf": (wrappedValue: autoTagOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "nsfw": (wrappedValue: nsfw?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLocal": (wrappedValue: isLocal?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "include": (wrappedValue: include?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "privacyOneOf": (wrappedValue: privacyOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasHLSFiles": (wrappedValue: hasHLSFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasWebVideoFiles": (wrappedValue: hasWebVideoFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "skipCount": (wrappedValue: skipCount?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "excludeAlreadyWatched": (wrappedValue: excludeAlreadyWatched?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "search": (wrappedValue: search?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoListResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     List storyboards of a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: ListVideoStoryboards200Response
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func listVideoStoryboards(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> ListVideoStoryboards200Response {
        return try await listVideoStoryboardsWithRequestBuilder(id: id, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     List storyboards of a video
     - GET /api/v1/videos/{id}/storyboards
     - **PeerTube >= 6.0**
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ListVideoStoryboards200Response> 
     */
    open class func listVideoStoryboardsWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<ListVideoStoryboards200Response> {
        var localVariablePath = "/api/v1/videos/{id}/storyboards"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ListVideoStoryboards200Response>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Update a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter thumbnailfile: (form) Video thumbnail file (optional)
     - parameter previewfile: (form) Video preview file (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter privacy: (form)  (optional)
     - parameter description: (form) Video description (optional)
     - parameter waitTranscoding: (form) Whether or not we wait transcoding before publish the video (optional)
     - parameter support: (form) A text tell the audience how to support the video creator (optional)
     - parameter nsfw: (form) Whether or not this video contains sensitive content (optional)
     - parameter name: (form) Video name (optional)
     - parameter tags: (form) Video tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Deprecated in 6.2, use commentsPolicy instead (optional)
     - parameter commentsPolicy: (form)  (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for this video (optional)
     - parameter originallyPublishedAt: (form) Date when the content was originally published (optional)
     - parameter scheduleUpdate: (form)  (optional)
     - parameter videoPasswords: (form)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func putVideo(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, thumbnailfile: URL? = nil, previewfile: URL? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, privacy: VideoPrivacySet? = nil, description: String? = nil, waitTranscoding: String? = nil, support: String? = nil, nsfw: Bool? = nil, name: String? = nil, tags: [String]? = nil, commentsEnabled: Bool? = nil, commentsPolicy: VideoCommentsPolicySet? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, videoPasswords: Set<String>? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await putVideoWithRequestBuilder(id: id, thumbnailfile: thumbnailfile, previewfile: previewfile, category: category, licence: licence, language: language, privacy: privacy, description: description, waitTranscoding: waitTranscoding, support: support, nsfw: nsfw, name: name, tags: tags, commentsEnabled: commentsEnabled, commentsPolicy: commentsPolicy, downloadEnabled: downloadEnabled, originallyPublishedAt: originallyPublishedAt, scheduleUpdate: scheduleUpdate, videoPasswords: videoPasswords, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Update a video
     - PUT /api/v1/videos/{id}
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter thumbnailfile: (form) Video thumbnail file (optional)
     - parameter previewfile: (form) Video preview file (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter privacy: (form)  (optional)
     - parameter description: (form) Video description (optional)
     - parameter waitTranscoding: (form) Whether or not we wait transcoding before publish the video (optional)
     - parameter support: (form) A text tell the audience how to support the video creator (optional)
     - parameter nsfw: (form) Whether or not this video contains sensitive content (optional)
     - parameter name: (form) Video name (optional)
     - parameter tags: (form) Video tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Deprecated in 6.2, use commentsPolicy instead (optional)
     - parameter commentsPolicy: (form)  (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for this video (optional)
     - parameter originallyPublishedAt: (form) Date when the content was originally published (optional)
     - parameter scheduleUpdate: (form)  (optional)
     - parameter videoPasswords: (form)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func putVideoWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, thumbnailfile: URL? = nil, previewfile: URL? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, privacy: VideoPrivacySet? = nil, description: String? = nil, waitTranscoding: String? = nil, support: String? = nil, nsfw: Bool? = nil, name: String? = nil, tags: [String]? = nil, commentsEnabled: Bool? = nil, commentsPolicy: VideoCommentsPolicySet? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, videoPasswords: Set<String>? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "thumbnailfile": thumbnailfile?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "previewfile": previewfile?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "category": category?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "licence": licence?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "language": language?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "privacy": privacy?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "description": description?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "waitTranscoding": waitTranscoding?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "support": support?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "nsfw": nsfw?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "name": name?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "tags": tags?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "commentsEnabled": commentsEnabled?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "commentsPolicy": commentsPolicy?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "downloadEnabled": downloadEnabled?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "originallyPublishedAt": originallyPublishedAt?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "scheduleUpdate": scheduleUpdate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "videoPasswords": videoPasswords?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Send chunk for the resumable replacement of a video
     
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentRange: (header) Specifies the bytes in the file that the request is uploading.  For example, a value of &#x60;bytes 0-262143/1000000&#x60; shows that the request is sending the first 262144 bytes (256 x 1024) in a 2,469,036 byte file.  
     - parameter contentLength: (header) Size of the chunk that the request is sending.  Remember that larger chunks are more efficient. PeerTube&#39;s web client uses chunks varying from 1048576 bytes (~1MB) and increases or reduces size depending on connection health.  
     - parameter body: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func replaceVideoSourceResumable(uploadId: String, contentRange: String, contentLength: Double, body: URL? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await replaceVideoSourceResumableWithRequestBuilder(uploadId: uploadId, contentRange: contentRange, contentLength: contentLength, body: body, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Send chunk for the resumable replacement of a video
     - PUT /api/v1/videos/{id}/source/replace-resumable
     - **PeerTube >= 6.0** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to continue, pause or resume the replacement of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentRange: (header) Specifies the bytes in the file that the request is uploading.  For example, a value of &#x60;bytes 0-262143/1000000&#x60; shows that the request is sending the first 262144 bytes (256 x 1024) in a 2,469,036 byte file.  
     - parameter contentLength: (header) Size of the chunk that the request is sending.  Remember that larger chunks are more efficient. PeerTube&#39;s web client uses chunks varying from 1048576 bytes (~1MB) and increases or reduces size depending on connection health.  
     - parameter body: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func replaceVideoSourceResumableWithRequestBuilder(uploadId: String, contentRange: String, contentLength: Double, body: URL? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/{id}/source/replace-resumable"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = ["body": body]

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "upload_id": (wrappedValue: uploadId.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/octet-stream",
            "Content-Range": contentRange.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "Content-Length": contentLength.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Cancel the resumable replacement of a video
     
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentLength: (header)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func replaceVideoSourceResumableCancel(uploadId: String, contentLength: Double, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await replaceVideoSourceResumableCancelWithRequestBuilder(uploadId: uploadId, contentLength: contentLength, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Cancel the resumable replacement of a video
     - DELETE /api/v1/videos/{id}/source/replace-resumable
     - **PeerTube >= 6.0** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to cancel the replacement of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - responseHeaders: [Content-Length(Double)]
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentLength: (header)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func replaceVideoSourceResumableCancelWithRequestBuilder(uploadId: String, contentLength: Double, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/{id}/source/replace-resumable"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "upload_id": (wrappedValue: uploadId.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Length": contentLength.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Initialize the resumable replacement of a video
     
     - parameter xUploadContentLength: (header) Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. 
     - parameter xUploadContentType: (header) MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. 
     - parameter videoReplaceSourceRequestResumable: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func replaceVideoSourceResumableInit(xUploadContentLength: Double, xUploadContentType: String, videoReplaceSourceRequestResumable: VideoReplaceSourceRequestResumable? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await replaceVideoSourceResumableInitWithRequestBuilder(xUploadContentLength: xUploadContentLength, xUploadContentType: xUploadContentType, videoReplaceSourceRequestResumable: videoReplaceSourceRequestResumable, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Initialize the resumable replacement of a video
     - POST /api/v1/videos/{id}/source/replace-resumable
     - **PeerTube >= 6.0** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to initialize the replacement of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter xUploadContentLength: (header) Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. 
     - parameter xUploadContentType: (header) MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. 
     - parameter videoReplaceSourceRequestResumable: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func replaceVideoSourceResumableInitWithRequestBuilder(xUploadContentLength: Double, xUploadContentType: String, videoReplaceSourceRequestResumable: VideoReplaceSourceRequestResumable? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/{id}/source/replace-resumable"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: videoReplaceSourceRequestResumable, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
            "X-Upload-Content-Length": xUploadContentLength.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "X-Upload-Content-Type": xUploadContentType.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Request video token
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoTokenResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func requestVideoToken(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoTokenResponse {
        return try await requestVideoTokenWithRequestBuilder(id: id, xPeertubeVideoPassword: xPeertubeVideoPassword, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Request video token
     - POST /api/v1/videos/{id}/token
     - Request special tokens that expire quickly to use them in some context (like accessing private static files)
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoTokenResponse> 
     */
    open class func requestVideoTokenWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoTokenResponse> {
        var localVariablePath = "/api/v1/videos/{id}/token"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "x-peertube-video-password": xPeertubeVideoPassword?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoTokenResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_searchVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter include
     */
    public enum Include_searchVideos: Int, Sendable, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case _4 = 4
        case _8 = 8
        case _16 = 16
        case _32 = 32
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_searchVideos: String, Sendable, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter searchTarget
     */
    public enum SearchTarget_searchVideos: String, Sendable, CaseIterable {
        case local = "local"
        case searchIndex = "search-index"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_searchVideos: String, Sendable, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case match = "-match"
    }

    /**
     Search videos
     
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.  
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter uuids: (query) Find elements with specific UUIDs (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort videos by criteria (prefixing with &#x60;-&#x60; means &#x60;DESC&#x60; order):  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter startDate: (query) Get videos that are published after this date (optional)
     - parameter endDate: (query) Get videos that are published before this date (optional)
     - parameter originallyPublishedStartDate: (query) Get videos that are originally published after this date (optional)
     - parameter originallyPublishedEndDate: (query) Get videos that are originally published before this date (optional)
     - parameter durationMin: (query) Get videos that have this minimum duration (optional)
     - parameter durationMax: (query) Get videos that have this maximum duration (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoListResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func searchVideos(search: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_searchVideos? = nil, isLocal: Bool? = nil, include: Include_searchVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, uuids: [String]? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_searchVideos? = nil, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideos? = nil, sort: Sort_searchVideos? = nil, excludeAlreadyWatched: Bool? = nil, host: String? = nil, startDate: Date? = nil, endDate: Date? = nil, originallyPublishedStartDate: Date? = nil, originallyPublishedEndDate: Date? = nil, durationMin: Int? = nil, durationMax: Int? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoListResponse {
        return try await searchVideosWithRequestBuilder(search: search, categoryOneOf: categoryOneOf, isLive: isLive, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, autoTagOneOf: autoTagOneOf, nsfw: nsfw, isLocal: isLocal, include: include, privacyOneOf: privacyOneOf, uuids: uuids, hasHLSFiles: hasHLSFiles, hasWebVideoFiles: hasWebVideoFiles, skipCount: skipCount, start: start, count: count, searchTarget: searchTarget, sort: sort, excludeAlreadyWatched: excludeAlreadyWatched, host: host, startDate: startDate, endDate: endDate, originallyPublishedStartDate: originallyPublishedStartDate, originallyPublishedEndDate: originallyPublishedEndDate, durationMin: durationMin, durationMax: durationMax, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Search videos
     - GET /api/v1/search/videos
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.  
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter autoTagOneOf: (query) **PeerTube &gt;&#x3D; 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote objects (optional)
     - parameter include: (query) **Only administrators and moderators can use this parameter**  Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES - &#x60;16&#x60; CAPTIONS - &#x60;32&#x60; VIDEO SOURCE  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter uuids: (query) Find elements with specific UUIDs (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort videos by criteria (prefixing with &#x60;-&#x60; means &#x60;DESC&#x60; order):  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter host: (query) Find elements owned by this host (optional)
     - parameter startDate: (query) Get videos that are published after this date (optional)
     - parameter endDate: (query) Get videos that are published before this date (optional)
     - parameter originallyPublishedStartDate: (query) Get videos that are originally published after this date (optional)
     - parameter originallyPublishedEndDate: (query) Get videos that are originally published before this date (optional)
     - parameter durationMin: (query) Get videos that have this minimum duration (optional)
     - parameter durationMax: (query) Get videos that have this maximum duration (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func searchVideosWithRequestBuilder(search: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, autoTagOneOf: GetAccountVideosTagsAllOfParameter? = nil, nsfw: Nsfw_searchVideos? = nil, isLocal: Bool? = nil, include: Include_searchVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, uuids: [String]? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_searchVideos? = nil, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideos? = nil, sort: Sort_searchVideos? = nil, excludeAlreadyWatched: Bool? = nil, host: String? = nil, startDate: Date? = nil, endDate: Date? = nil, originallyPublishedStartDate: Date? = nil, originallyPublishedEndDate: Date? = nil, durationMin: Int? = nil, durationMax: Int? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoListResponse> {
        let localVariablePath = "/api/v1/search/videos"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "search": (wrappedValue: search.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "categoryOneOf": (wrappedValue: categoryOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLive": (wrappedValue: isLive?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsOneOf": (wrappedValue: tagsOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tagsAllOf": (wrappedValue: tagsAllOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "licenceOneOf": (wrappedValue: licenceOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "languageOneOf": (wrappedValue: languageOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "autoTagOneOf": (wrappedValue: autoTagOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "nsfw": (wrappedValue: nsfw?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "isLocal": (wrappedValue: isLocal?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "include": (wrappedValue: include?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "privacyOneOf": (wrappedValue: privacyOneOf?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "uuids": (wrappedValue: uuids?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasHLSFiles": (wrappedValue: hasHLSFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "hasWebVideoFiles": (wrappedValue: hasWebVideoFiles?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "skipCount": (wrappedValue: skipCount?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchTarget": (wrappedValue: searchTarget?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "excludeAlreadyWatched": (wrappedValue: excludeAlreadyWatched?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "host": (wrappedValue: host?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "startDate": (wrappedValue: startDate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endDate": (wrappedValue: endDate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "originallyPublishedStartDate": (wrappedValue: originallyPublishedStartDate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "originallyPublishedEndDate": (wrappedValue: originallyPublishedEndDate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "durationMin": (wrappedValue: durationMin?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "durationMax": (wrappedValue: durationMax?.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoListResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Update information about a live
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter liveVideoUpdate: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func updateLiveId(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, liveVideoUpdate: LiveVideoUpdate? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await updateLiveIdWithRequestBuilder(id: id, liveVideoUpdate: liveVideoUpdate, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Update information about a live
     - PUT /api/v1/videos/live/{id}
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter liveVideoUpdate: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func updateLiveIdWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, liveVideoUpdate: LiveVideoUpdate? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/live/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: liveVideoUpdate, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Upload a video
     
     - parameter name: (form) Video name 
     - parameter channelId: (form) Channel id that will contain this video 
     - parameter videofile: (form) Video file 
     - parameter privacy: (form)  (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter description: (form) Video description (optional)
     - parameter waitTranscoding: (form) Whether or not we wait transcoding before publish the video (optional)
     - parameter generateTranscription: (form) **PeerTube &gt;&#x3D; 6.2** If enabled by the admin, automatically generate a subtitle of the video (optional)
     - parameter support: (form) A text tell the audience how to support the video creator (optional)
     - parameter nsfw: (form) Whether or not this video contains sensitive content (optional)
     - parameter tags: (form) Video tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Deprecated in 6.2, use commentsPolicy instead (optional)
     - parameter commentsPolicy: (form)  (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for this video (optional)
     - parameter originallyPublishedAt: (form) Date when the content was originally published (optional)
     - parameter scheduleUpdate: (form)  (optional)
     - parameter thumbnailfile: (form) Video thumbnail file (optional)
     - parameter previewfile: (form) Video preview file (optional)
     - parameter videoPasswords: (form)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoUploadResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func uploadLegacy(name: String, channelId: Int, videofile: URL, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, waitTranscoding: Bool? = nil, generateTranscription: Bool? = nil, support: String? = nil, nsfw: Bool? = nil, tags: Set<String>? = nil, commentsEnabled: Bool? = nil, commentsPolicy: VideoCommentsPolicySet? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, videoPasswords: Set<String>? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoUploadResponse {
        return try await uploadLegacyWithRequestBuilder(name: name, channelId: channelId, videofile: videofile, privacy: privacy, category: category, licence: licence, language: language, description: description, waitTranscoding: waitTranscoding, generateTranscription: generateTranscription, support: support, nsfw: nsfw, tags: tags, commentsEnabled: commentsEnabled, commentsPolicy: commentsPolicy, downloadEnabled: downloadEnabled, originallyPublishedAt: originallyPublishedAt, scheduleUpdate: scheduleUpdate, thumbnailfile: thumbnailfile, previewfile: previewfile, videoPasswords: videoPasswords, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Upload a video
     - POST /api/v1/videos/upload
     - Uses a single request to upload a video.
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter name: (form) Video name 
     - parameter channelId: (form) Channel id that will contain this video 
     - parameter videofile: (form) Video file 
     - parameter privacy: (form)  (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter description: (form) Video description (optional)
     - parameter waitTranscoding: (form) Whether or not we wait transcoding before publish the video (optional)
     - parameter generateTranscription: (form) **PeerTube &gt;&#x3D; 6.2** If enabled by the admin, automatically generate a subtitle of the video (optional)
     - parameter support: (form) A text tell the audience how to support the video creator (optional)
     - parameter nsfw: (form) Whether or not this video contains sensitive content (optional)
     - parameter tags: (form) Video tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Deprecated in 6.2, use commentsPolicy instead (optional)
     - parameter commentsPolicy: (form)  (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for this video (optional)
     - parameter originallyPublishedAt: (form) Date when the content was originally published (optional)
     - parameter scheduleUpdate: (form)  (optional)
     - parameter thumbnailfile: (form) Video thumbnail file (optional)
     - parameter previewfile: (form) Video preview file (optional)
     - parameter videoPasswords: (form)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoUploadResponse> 
     */
    open class func uploadLegacyWithRequestBuilder(name: String, channelId: Int, videofile: URL, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, waitTranscoding: Bool? = nil, generateTranscription: Bool? = nil, support: String? = nil, nsfw: Bool? = nil, tags: Set<String>? = nil, commentsEnabled: Bool? = nil, commentsPolicy: VideoCommentsPolicySet? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, videoPasswords: Set<String>? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoUploadResponse> {
        let localVariablePath = "/api/v1/videos/upload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "name": name.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "channelId": channelId.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "privacy": privacy?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "category": category?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "licence": licence?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "language": language?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "description": description?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "waitTranscoding": waitTranscoding?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "generateTranscription": generateTranscription?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "support": support?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "nsfw": nsfw?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "tags": tags?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "commentsEnabled": commentsEnabled?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "commentsPolicy": commentsPolicy?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "downloadEnabled": downloadEnabled?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "originallyPublishedAt": originallyPublishedAt?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "scheduleUpdate": scheduleUpdate?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "thumbnailfile": thumbnailfile?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "previewfile": previewfile?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "videoPasswords": videoPasswords?.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "videofile": videofile.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoUploadResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Send chunk for the resumable upload of a video
     
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentRange: (header) Specifies the bytes in the file that the request is uploading.  For example, a value of &#x60;bytes 0-262143/1000000&#x60; shows that the request is sending the first 262144 bytes (256 x 1024) in a 2,469,036 byte file.  
     - parameter contentLength: (header) Size of the chunk that the request is sending.  Remember that larger chunks are more efficient. PeerTube&#39;s web client uses chunks varying from 1048576 bytes (~1MB) and increases or reduces size depending on connection health.  
     - parameter body: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: VideoUploadResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func uploadResumable(uploadId: String, contentRange: String, contentLength: Double, body: URL? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> VideoUploadResponse {
        return try await uploadResumableWithRequestBuilder(uploadId: uploadId, contentRange: contentRange, contentLength: contentLength, body: body, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Send chunk for the resumable upload of a video
     - PUT /api/v1/videos/upload-resumable
     - Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to continue, pause or resume the upload of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - responseHeaders: [Content-Length(Double)]
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentRange: (header) Specifies the bytes in the file that the request is uploading.  For example, a value of &#x60;bytes 0-262143/1000000&#x60; shows that the request is sending the first 262144 bytes (256 x 1024) in a 2,469,036 byte file.  
     - parameter contentLength: (header) Size of the chunk that the request is sending.  Remember that larger chunks are more efficient. PeerTube&#39;s web client uses chunks varying from 1048576 bytes (~1MB) and increases or reduces size depending on connection health.  
     - parameter body: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VideoUploadResponse> 
     */
    open class func uploadResumableWithRequestBuilder(uploadId: String, contentRange: String, contentLength: Double, body: URL? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<VideoUploadResponse> {
        let localVariablePath = "/api/v1/videos/upload-resumable"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = ["body": body]

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "upload_id": (wrappedValue: uploadId.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/octet-stream",
            "Content-Range": contentRange.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "Content-Length": contentLength.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoUploadResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Cancel the resumable upload of a video, deleting any data uploaded so far
     
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentLength: (header)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func uploadResumableCancel(uploadId: String, contentLength: Double, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await uploadResumableCancelWithRequestBuilder(uploadId: uploadId, contentLength: contentLength, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Cancel the resumable upload of a video, deleting any data uploaded so far
     - DELETE /api/v1/videos/upload-resumable
     - Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to cancel the upload of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - responseHeaders: [Content-Length(Double)]
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentLength: (header)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func uploadResumableCancelWithRequestBuilder(uploadId: String, contentLength: Double, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/upload-resumable"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "upload_id": (wrappedValue: uploadId.encodeToJSON(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Length": contentLength.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Initialize the resumable upload of a video
     
     - parameter xUploadContentLength: (header) Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. 
     - parameter xUploadContentType: (header) MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. 
     - parameter videoUploadRequestResumable: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func uploadResumableInit(xUploadContentLength: Double, xUploadContentType: String, videoUploadRequestResumable: VideoUploadRequestResumable? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) {
        return try await uploadResumableInitWithRequestBuilder(xUploadContentLength: xUploadContentLength, xUploadContentType: xUploadContentType, videoUploadRequestResumable: videoUploadRequestResumable, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Initialize the resumable upload of a video
     - POST /api/v1/videos/upload-resumable
     - Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to initialize the upload of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter xUploadContentLength: (header) Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. 
     - parameter xUploadContentType: (header) MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. 
     - parameter videoUploadRequestResumable: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func uploadResumableInitWithRequestBuilder(xUploadContentLength: Double, xUploadContentType: String, videoUploadRequestResumable: VideoUploadRequestResumable? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/upload-resumable"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: videoUploadRequestResumable, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
            "X-Upload-Content-Length": xUploadContentLength.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
            "X-Upload-Content-Type": xUploadContentType.encodeToJSON(codableHelper: apiConfiguration.codableHelper),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }
}
