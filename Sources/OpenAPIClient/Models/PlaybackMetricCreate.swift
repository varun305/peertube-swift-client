//
// PlaybackMetricCreate.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct PlaybackMetricCreate: Sendable, Codable, JSONEncodable, Hashable {

    public enum PlayerMode: String, Sendable, Codable, CaseIterable {
        case p2pMediaLoader = "p2p-media-loader"
        case webVideo = "web-video"
    }
    public var playerMode: PlayerMode
    /** Current player video resolution */
    public var resolution: Double?
    /** Current player video fps */
    public var fps: Double?
    public var p2pEnabled: Bool
    /** P2P peers connected (doesn't include WebSeed peers) */
    public var p2pPeers: Double?
    /** How many resolution changes occurred since the last metric creation */
    public var resolutionChanges: Double
    /** How many times buffer has been stalled since the last metric creation */
    public var bufferStalled: Double?
    /** How many errors occurred since the last metric creation */
    public var errors: Double
    /** How many bytes were downloaded with P2P since the last metric creation */
    public var downloadedBytesP2P: Double
    /** How many bytes were downloaded with HTTP since the last metric creation */
    public var downloadedBytesHTTP: Double
    /** How many bytes were uploaded with P2P since the last metric creation */
    public var uploadedBytesP2P: Double
    public var videoId: ApiV1VideosOwnershipIdAcceptPostIdParameter

    public init(playerMode: PlayerMode, resolution: Double? = nil, fps: Double? = nil, p2pEnabled: Bool, p2pPeers: Double? = nil, resolutionChanges: Double, bufferStalled: Double? = nil, errors: Double, downloadedBytesP2P: Double, downloadedBytesHTTP: Double, uploadedBytesP2P: Double, videoId: ApiV1VideosOwnershipIdAcceptPostIdParameter) {
        self.playerMode = playerMode
        self.resolution = resolution
        self.fps = fps
        self.p2pEnabled = p2pEnabled
        self.p2pPeers = p2pPeers
        self.resolutionChanges = resolutionChanges
        self.bufferStalled = bufferStalled
        self.errors = errors
        self.downloadedBytesP2P = downloadedBytesP2P
        self.downloadedBytesHTTP = downloadedBytesHTTP
        self.uploadedBytesP2P = uploadedBytesP2P
        self.videoId = videoId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case playerMode
        case resolution
        case fps
        case p2pEnabled
        case p2pPeers
        case resolutionChanges
        case bufferStalled
        case errors
        case downloadedBytesP2P
        case downloadedBytesHTTP
        case uploadedBytesP2P
        case videoId
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(playerMode, forKey: .playerMode)
        try container.encodeIfPresent(resolution, forKey: .resolution)
        try container.encodeIfPresent(fps, forKey: .fps)
        try container.encode(p2pEnabled, forKey: .p2pEnabled)
        try container.encodeIfPresent(p2pPeers, forKey: .p2pPeers)
        try container.encode(resolutionChanges, forKey: .resolutionChanges)
        try container.encodeIfPresent(bufferStalled, forKey: .bufferStalled)
        try container.encode(errors, forKey: .errors)
        try container.encode(downloadedBytesP2P, forKey: .downloadedBytesP2P)
        try container.encode(downloadedBytesHTTP, forKey: .downloadedBytesHTTP)
        try container.encode(uploadedBytesP2P, forKey: .uploadedBytesP2P)
        try container.encode(videoId, forKey: .videoId)
    }
}

