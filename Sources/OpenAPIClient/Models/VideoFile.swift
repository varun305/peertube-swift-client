//
// VideoFile.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct VideoFile: Sendable, Codable, JSONEncodable, Hashable {

    public static let idRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    public static let magnetUriRule = StringRule(minLength: nil, maxLength: nil, pattern: "/magnet:\\?xt=urn:[a-z0-9]+:[a-z0-9]{32}/i")
    public var id: Int?
    /** magnet URI allowing to resolve the video via BitTorrent without a metainfo file */
    public var magnetUri: String?
    public var resolution: VideoResolutionConstant?
    /** Video file size in bytes */
    public var size: Int?
    /** Direct URL of the torrent file */
    public var torrentUrl: String?
    /** URL endpoint that transfers the torrent file as an attachment (so that the browser opens a download dialog) */
    public var torrentDownloadUrl: String?
    /** Direct URL of the video */
    public var fileUrl: String?
    /** Playlist URL of the file if it is owned by a playlist */
    public var playlistUrl: String?
    /** URL endpoint that transfers the video file as an attachment (so that the browser opens a download dialog) */
    public var fileDownloadUrl: String?
    /** Frames per second of the video file */
    public var fps: Double?
    /** **PeerTube >= 6.1** Video stream width */
    public var width: Double?
    /** **PeerTube >= 6.1** Video stream height */
    public var height: Double?
    /** URL dereferencing the output of ffprobe on the file */
    public var metadataUrl: String?
    /** **PeerTube >= 6.2** The file container has an audio stream */
    public var hasAudio: Bool?
    /** **PeerTube >= 6.2** The file container has a video stream */
    public var hasVideo: Bool?
    public var storage: FileStorage?

    public init(id: Int? = nil, magnetUri: String? = nil, resolution: VideoResolutionConstant? = nil, size: Int? = nil, torrentUrl: String? = nil, torrentDownloadUrl: String? = nil, fileUrl: String? = nil, playlistUrl: String? = nil, fileDownloadUrl: String? = nil, fps: Double? = nil, width: Double? = nil, height: Double? = nil, metadataUrl: String? = nil, hasAudio: Bool? = nil, hasVideo: Bool? = nil, storage: FileStorage? = nil) {
        self.id = id
        self.magnetUri = magnetUri
        self.resolution = resolution
        self.size = size
        self.torrentUrl = torrentUrl
        self.torrentDownloadUrl = torrentDownloadUrl
        self.fileUrl = fileUrl
        self.playlistUrl = playlistUrl
        self.fileDownloadUrl = fileDownloadUrl
        self.fps = fps
        self.width = width
        self.height = height
        self.metadataUrl = metadataUrl
        self.hasAudio = hasAudio
        self.hasVideo = hasVideo
        self.storage = storage
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case magnetUri
        case resolution
        case size
        case torrentUrl
        case torrentDownloadUrl
        case fileUrl
        case playlistUrl
        case fileDownloadUrl
        case fps
        case width
        case height
        case metadataUrl
        case hasAudio
        case hasVideo
        case storage
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(magnetUri, forKey: .magnetUri)
        try container.encodeIfPresent(resolution, forKey: .resolution)
        try container.encodeIfPresent(size, forKey: .size)
        try container.encodeIfPresent(torrentUrl, forKey: .torrentUrl)
        try container.encodeIfPresent(torrentDownloadUrl, forKey: .torrentDownloadUrl)
        try container.encodeIfPresent(fileUrl, forKey: .fileUrl)
        try container.encodeIfPresent(playlistUrl, forKey: .playlistUrl)
        try container.encodeIfPresent(fileDownloadUrl, forKey: .fileDownloadUrl)
        try container.encodeIfPresent(fps, forKey: .fps)
        try container.encodeIfPresent(width, forKey: .width)
        try container.encodeIfPresent(height, forKey: .height)
        try container.encodeIfPresent(metadataUrl, forKey: .metadataUrl)
        try container.encodeIfPresent(hasAudio, forKey: .hasAudio)
        try container.encodeIfPresent(hasVideo, forKey: .hasVideo)
        try container.encodeIfPresent(storage, forKey: .storage)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension VideoFile: Identifiable {}
