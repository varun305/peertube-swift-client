//
// VideoUploadRequestResumable.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct VideoUploadRequestResumable: Sendable, Codable, JSONEncodable, Hashable {

    public static let nameRule = StringRule(minLength: 3, maxLength: 120, pattern: nil)
    public static let channelIdRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    public static let tagsRule = ArrayRule(minItems: 1, maxItems: 5, uniqueItems: true)
    public static let videoPasswordsRule = ArrayRule(minItems: nil, maxItems: nil, uniqueItems: true)
    /** Video name */
    public var name: String
    /** Channel id that will contain this video */
    public var channelId: Int
    public var privacy: VideoPrivacySet?
    /** category id of the video (see [/videos/categories](#operation/getCategories)) */
    public var category: Int?
    /** licence id of the video (see [/videos/licences](#operation/getLicences)) */
    public var licence: Int?
    /** language id of the video (see [/videos/languages](#operation/getLanguages)) */
    public var language: String?
    /** Video description */
    public var description: String?
    /** Whether or not we wait transcoding before publish the video */
    public var waitTranscoding: Bool?
    /** **PeerTube >= 6.2** If enabled by the admin, automatically generate a subtitle of the video */
    public var generateTranscription: Bool?
    /** A text tell the audience how to support the video creator */
    public var support: String?
    /** Whether or not this video contains sensitive content */
    public var nsfw: Bool?
    /** Video tags (maximum 5 tags each between 2 and 30 characters) */
    public var tags: Set<String>?
    /** Deprecated in 6.2, use commentsPolicy instead */
    @available(*, deprecated, message: "This property is deprecated.")
    public var commentsEnabled: Bool?
    public var commentsPolicy: VideoCommentsPolicySet?
    /** Enable or disable downloading for this video */
    public var downloadEnabled: Bool?
    /** Date when the content was originally published */
    public var originallyPublishedAt: Date?
    public var scheduleUpdate: VideoScheduledUpdate?
    /** Video thumbnail file */
    public var thumbnailfile: URL?
    /** Video preview file */
    public var previewfile: URL?
    public var videoPasswords: Set<String>?
    /** Video filename including extension */
    public var filename: String

    public init(name: String, channelId: Int, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, waitTranscoding: Bool? = nil, generateTranscription: Bool? = nil, support: String? = nil, nsfw: Bool? = nil, tags: Set<String>? = nil, commentsEnabled: Bool? = nil, commentsPolicy: VideoCommentsPolicySet? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, videoPasswords: Set<String>? = nil, filename: String) {
        self.name = name
        self.channelId = channelId
        self.privacy = privacy
        self.category = category
        self.licence = licence
        self.language = language
        self.description = description
        self.waitTranscoding = waitTranscoding
        self.generateTranscription = generateTranscription
        self.support = support
        self.nsfw = nsfw
        self.tags = tags
        self.commentsEnabled = commentsEnabled
        self.commentsPolicy = commentsPolicy
        self.downloadEnabled = downloadEnabled
        self.originallyPublishedAt = originallyPublishedAt
        self.scheduleUpdate = scheduleUpdate
        self.thumbnailfile = thumbnailfile
        self.previewfile = previewfile
        self.videoPasswords = videoPasswords
        self.filename = filename
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case channelId
        case privacy
        case category
        case licence
        case language
        case description
        case waitTranscoding
        case generateTranscription
        case support
        case nsfw
        case tags
        case commentsEnabled
        case commentsPolicy
        case downloadEnabled
        case originallyPublishedAt
        case scheduleUpdate
        case thumbnailfile
        case previewfile
        case videoPasswords
        case filename
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(channelId, forKey: .channelId)
        try container.encodeIfPresent(privacy, forKey: .privacy)
        try container.encodeIfPresent(category, forKey: .category)
        try container.encodeIfPresent(licence, forKey: .licence)
        try container.encodeIfPresent(language, forKey: .language)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(waitTranscoding, forKey: .waitTranscoding)
        try container.encodeIfPresent(generateTranscription, forKey: .generateTranscription)
        try container.encodeIfPresent(support, forKey: .support)
        try container.encodeIfPresent(nsfw, forKey: .nsfw)
        try container.encodeIfPresent(tags, forKey: .tags)
        try container.encodeIfPresent(commentsEnabled, forKey: .commentsEnabled)
        try container.encodeIfPresent(commentsPolicy, forKey: .commentsPolicy)
        try container.encodeIfPresent(downloadEnabled, forKey: .downloadEnabled)
        try container.encodeIfPresent(originallyPublishedAt, forKey: .originallyPublishedAt)
        try container.encodeIfPresent(scheduleUpdate, forKey: .scheduleUpdate)
        try container.encodeIfPresent(thumbnailfile, forKey: .thumbnailfile)
        try container.encodeIfPresent(previewfile, forKey: .previewfile)
        try container.encodeIfPresent(videoPasswords, forKey: .videoPasswords)
        try container.encode(filename, forKey: .filename)
    }
}

